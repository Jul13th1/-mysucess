1.IO多路复用，select、poll、epoll 的区别？
    1.select
        实现多路复用的方式是，将已连接的 Socket 都放到一个文件描述符集合，然后调用 select 函数将文件描述符集合拷贝到内核里，让内核来检查是否有网络事件产生，
    检查的方式很粗暴，就是通过遍历文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合拷贝回用户态里，然后用
    户态还需要再通过遍历的方法找到可读或可写的 Socket，然后再对其处理。

        所以，对于 select 这种方式，需要进行 2 次「遍历」文件描述符集合，一次是在内核态里，一个次是在用户态里 ，
        而且还会发生 2 次「拷贝」文件描述符集合，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。
    select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 1024，只能监听 0~1023 的文件描述符。

    2.poll 
        不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。
        但是 poll 和 select 并没有太大的本质区别，都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，
        时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合，这种方式随着并发数上来，性能的损耗会呈指数级增长。

    3.epoll
        通过两个方面，很好解决了 select/poll 的问题
        第一点：
            epoll 在内核里使用红黑树来跟踪进程所有待检测的文件描述字，把需要监控的 socket 通过 epoll_ctl() 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 O(logn)。
        而 select/poll 内核里没有类似 epoll 红黑树这种保存所有待检测的 socket 的数据结构，所以 select/poll 每次操作时都传入整个 socket 集合给内核，而 epoll 因为在内核维护了红黑树，可以保存所有
        待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。
        第二点：
            epoll 使用事件驱动的机制，内核里维护了一个链表来记录就绪事件，当某个 socket 有事件发生时，通过回调函数内核会将其加入到这个就绪事件列表中，当用户调用 epoll_wait() 函数时，
        只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。

执行顺序总结：
    1.创建 epoll 实例：
        调用 epoll_create 来创建一个 epoll 实例，返回 epoll 文件描述符。
    2.注册文件描述符：
        使用 epoll_ctl 注册或修改文件描述符，指定要监听的事件类型。
    3.等待事件发生：
        调用 epoll_wait 阻塞（或非阻塞）等待已注册文件描述符上的 I/O 事件发生，并处理返回的事件。
    总结：
    epoll_create：创建 epoll 实例，返回 epoll 文件描述符。
    epoll_ctl：将文件描述符和对应的事件注册到 epoll 实例中。
    epoll_wait：阻塞（或非阻塞）等待事件的发生，并返回准备好的文件描述符和事件。
    通过这种机制，单个线程可以高效地处理大量的并发连接，避免了每个连接都创建一个线程带来的性能和资源消耗。

2.epoll和线程对比：
    epoll 和线程是两种不同的并发处理机制，它们的工作原理、使用场景和性能特征各不相同
    1. 基本概念
        epoll：
            epoll 是 Linux 提供的一个 I/O 多路复用机制，用于处理大量的并发 I/O 操作。
            它允许单个线程在事件循环中监控多个文件描述符的 I/O 状态，从而实现高效的并发处理。epoll 通过非阻塞 I/O 和事件通知机制来管理大量的连接，避免了频繁的线程切换。
        线程：
            操作系统调度的基本单位，多个线程可以并发执行，甚至在多核 CPU 上同时运行。线程通常用于处理多任务并发，尤其是 CPU 密集型任务。
            每个线程都有独立的堆栈和执行上下文，线程间通过共享内存和同步机制进行通信。
    2. 工作原理
        epoll：
            1.epoll 通过在一个线程内使用事件循环，监听多个文件描述符（如 socket）的 I/O 事件。
            2.当某个文件描述符准备好 I/O 操作（如可读、可写、异常等）时，epoll 会通知程序进行处理。
            3.只有当某个事件发生时，程序才会处理该事件，避免了阻塞等待，节省了大量的资源。
        线程：
            1.每个线程都可以独立地执行任务。线程通常是阻塞的，除非使用非阻塞 I/O 或者线程内部的同步机制。
            2.线程可以并行执行任务，因此适合处理 CPU 密集型任务或需要独立状态的任务。
            3.每个线程都有自己的栈和寄存器上下文，因此线程切换开销较大。
    3. 使用场景
        epoll：
            适合 I/O 密集型任务，尤其是网络服务器需要处理大量并发的网络连接时。epoll 能够高效地处理大量的客户端连接，而不需要为每个连接都创建一个线程。
            常见的应用场景：高性能网络服务器（如 HTTP 服务器、数据库服务器等）、事件驱动的程序。
        线程：
            适合 CPU 密集型任务，如数据计算、图像处理、加密解密等。
            线程可以处理多个任务，并且能够利用多核处理器的并行能力。对于复杂的任务，多个线程可以同时处理不同部分，缩短整体执行时间。
            常见的应用场景：多核 CPU 下的并行计算、异步任务处理等。
    4. 性能和效率
        epoll：
            由于 epoll 是基于事件驱动的，它能够在一个线程中管理多个 I/O 操作，避免了线程上下文切换的开销，效率非常高。
            epoll 采用边缘触发（Edge Triggered）和水平触发（Level Triggered）两种模式，能够进一步减少不必要的事件通知和检查，提高性能。
            高效的 I/O 多路复用，适用于大规模并发连接（如 Web 服务器）。
            epoll 的缺点是它对 CPU 密集型任务不适用，因为它只处理 I/O 事件，无法充分利用多核 CPU 进行并行计算。
        线程：
            线程适合处理 CPU 密集型任务，可以利用多核 CPU 进行并行计算。
            线程的开销相对较大，尤其是在大量线程并发时，操作系统需要频繁地进行线程切换，这会增加额外的 CPU 和内存开销。
            使用线程时，通常需要同步机制来确保线程之间的共享数据一致性，这增加了复杂性和性能开销。
    5. 内存和资源消耗
        epoll：
            epoll 在使用时，通常只需要一个线程和少量的内存来管理多个文件描述符，内存和资源消耗较小。
            因为 epoll 是事件驱动的，它避免了每个连接都创建一个线程，从而节省了线程上下文切换的开销和线程栈的内存。
        线程：
            每个线程都有自己的栈空间和上下文，需要占用一定的内存。
            当有大量线程时，操作系统需要频繁进行线程调度和上下文切换，这会消耗更多的 CPU 时间。
            线程池可以用来优化线程管理，减少线程的创建和销毁开销，但如果并发线程数过多，仍然会面临性能瓶颈。
    6. 易用性和复杂性
        epoll：
            epoll 是事件驱动的编程模型，通常需要手动管理事件循环，处理文件描述符的读写操作。相比线程模型，epoll 的编程模型可能较为复杂。
            需要理解非阻塞 I/O 和事件通知机制，调试可能相对较困难。
        线程：
            线程模型更为直观，适合许多传统的编程任务。
            线程间通信和同步（如互斥锁、条件变量）是需要注意的难点，尤其是在多线程同时操作共享资源时，容易产生死锁和竞态条件。
    7. 扩展性
        epoll：
            epoll 非常适合扩展到大规模的网络应用，能够处理成千上万的并发连接。由于只使用少量线程（通常是一个），它的扩展性非常好。
            通过事件驱动和 I/O 多路复用，服务器可以在有限的资源下处理大量并发请求。
        线程：
            多线程模型在 CPU 密集型任务下表现较好，但线程数量过多时会面临线程调度开销、内存占用和线程管理的挑战。
            线程池可以在一定程度上改善线程管理，但在极高并发的情况下，仍然会遇到瓶颈。

3.epoll 模型的水平和边缘触发模式的区别？
    epoll 是 Linux 提供的一种高效的 I/O 多路复用机制，它比传统的 select 和 poll 更具性能优势，特别是在处理大量并发连接时。
    epoll 支持两种触发模式：水平触发（Level-Triggered, LT）和边缘触发（Edge-Triggered, ET）。这两种模式的主要区别在于事件通知的方式和触发条件的不同。

    1. 水平触发（Level-Triggered, LT）
        水平触发是 epoll 默认的触发模式。在这种模式下，当 epoll 监听的文件描述符上有事件发生时（如数据可读、可写或异常等），只要事件没有被处理，epoll 就会持续通知应用程序。
    事件通知条件：当事件发生时，epoll 会持续返回该文件描述符，直到事件被处理完。
        行为特点：
            如果某个文件描述符的数据还没有完全读取（比如缓冲区没清空），即使之前通知过，epoll 会继续通知应用程序。
            epoll_wait() 会多次返回相同的事件，直到应用程序处理完相关的 I/O 操作。
            对于每个文件描述符，epoll 会确保当事件发生时，会多次通知，直到该事件处理完为止。
        适用场景：适合数据流较慢或不频繁的场景。由于它会持续通知应用程序，直到事件被完全处理，可以比较简单地处理事件。
        示例：
            如果一个套接字有数据可读，epoll 会每次调用 epoll_wait() 都返回这个套接字，直到应用程序读取完所有数据。
    2.边缘触发（Edge-Triggered, ET）
        边缘触发模式是 epoll 的高级模式。它在文件描述符的状态发生变化时，只会通知一次，直到应用程序处理了相应的事件。如果事件没有被处理，epoll 将不会再通知应用程序。
        事件通知条件：epoll 只会在事件的状态发生变化时通知应用程序，即当事件首次发生时通知一次。如果事件没有被处理（例如数据未被完全读取），则 epoll 不会再通知。
            行为特点：
                只会通知一次事件的发生，当数据到达或文件描述符的状态发生变化时，epoll 会立即返回。
                如果应用程序没有立即处理所有数据，后续不会再被通知，因此必须一次性读取或写入所有数据，避免漏掉事件。
                非阻塞 I/O通常是边缘触发模式的搭配方式，应用程序需要非常注意事件的处理逻辑。
        适用场景：适合数据流量较大，事件发生频繁，且希望高效处理 I/O 的场景。边缘触发通过减少系统调用次数（通知次数）来提高性能。
    示例：
假设一个套接字有数据可读，epoll 只会在数据到达时通知一次。如果应用程序没有在第一次通知时读取所有数据，epoll 就不会再通知它，直到应用程序重新处理这个套接字的状态（通常是调用 epoll_wait() 重新检测）。

4.假设我某个客户端 socket 绑定到 epollfd 上后使用边缘触发模式，现在该客户端发来了 100 个字节，是否会触发读事件；
  服务端收了 50 个字节，读事件会在下一轮中继续触发吗？假设接着客户端又发了 10 字节，此时服务端会触发读事件吗？
    1. 客户端发送 100 字节数据
        在边缘触发（ET）模式下，epoll 只会在事件发生的“边缘”时通知一次。所以，当客户端第一次发送 100 个字节数据时，epoll 会通知服务端发生了 读事件，即数据可读。
        触发读事件：当客户端发送 100 字节数据时，epoll 会触发一次 读事件，通知服务端数据可读。此时，服务端应该尽可能读取数据。如果服务端使用的是非阻塞 I/O（通常与边缘触发模式一起使用），它会立即读取所有可用的数据。
    2. 服务端读取了 50 字节数据
        假设服务端在接收到读事件后读取了 50 字节数据。由于 边缘触发模式的特性，epoll 只会在状态变化时通知一次，如果数据未完全读取，epoll 不会继续触发后续的读事件，直到状态发生变化。
        状态变化：在此情况下，epoll 会认为客户端数据读取完毕（或者数据缓冲区中没有更多数据），因此它不会再次触发读事件。
        继续读取未读取的数据：虽然客户端还有 50 字节未读取，但在边缘触发模式下，由于服务端已经处理了第一次的读事件（即数据缓冲区状态发生变化），epoll 不会再在当前事件循环中触发读事件。
    3. 客户端再次发送 10 字节数据
        接下来，客户端又发送了 10 字节数据。此时，数据缓冲区的状态发生了变化（因为又有新数据到达），这意味着 边缘触发模式下，epoll 会检测到状态变化并再次触发读事件。
        触发新的读事件：由于数据缓冲区的状态发生了变化，epoll 会通知服务端有新的数据可以读取。因此，服务端会在下一轮 epoll_wait() 中收到新的读事件通知。
        第二次触发读事件时，服务端会读取新到的 10 字节数据，而不是重新读取已经读取的 50 字节。所以，第二次触发的读事件不会让服务端读取到总共 60 字节的数据。而是读取到 10 字节数据（新的数据），
        最终总共会读取到 60 字节数据（50 字节 + 10 字节）。
    总结
        1.第一次客户端发送 100 字节数据，epoll 触发读事件通知服务端。
        2.服务端读取了 50 字节数据后，epoll 不会继续触发读事件，直到数据的状态发生变化（例如客户端再次发送数据）。
        3.客户端再次发送 10 字节数据，由于数据缓冲区的状态发生变化，epoll 会触发新的读事件，服务端会读取剩余的 10 字节。

