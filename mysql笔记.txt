1.什么是索引？
    （1）索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。
    （2）索引的实现通常使用B树及其变种B+树
    （3）通过对内容建立索引形成目录。而且索引是一个文件，它是要占据物理空间的。
    说明：MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。
         比如我们在查字典的时候，前面都有检索的拼音和偏旁、笔画等，然后找到对应字典页码，这样然后就打开字典的页数就可以知道我们要搜索的某一个key的全部值的信息了。

2.索引有哪些优缺点？
    索引的优点：
        （1）可以大大的加快对数据的检索速度，这也是创建索引的最主要原因
        （2）通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能
    索引的缺点：
        （1）时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也需要动态的维护，
                     会降低增删改的效率。
        （2）空间方面：索引需要占物理空间

3.MySQL有哪几种索引类型？
    1.从存储结构上来划分：
        BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引。这里所描述的是索引储存时保存的形式
    2.从应用层次来分：
        （1）普通索引：即一个索引只包含单个列，一个表可以有多个单列索引
            CREATE INDEX idx_username ON users (username);
            普通索引是针对单列创建的索引，它加速了基于该列的查询。
            一个表可以有多个单列索引。
            这些索引可以让查询在指定列上更高效，但每个索引都是独立存在的，不会影响其他列的查询。
        （2）唯一索引：索引列的值必须唯一，但允许有空值
            CREATE UNIQUE INDEX idx_email ON users (email);
            唯一性约束： 唯一索引确保索引列的每个值在表中都是唯一的（没有重复）。
            允许空值： 唯一索引允许空值（NULL），并且多个空值被认为是不同的，因此允许多个空值。
            性能： 唯一索引仍然具有加速查询的功能，同时提供唯一性约束。
                主键与唯一索引的区别：
                    主键索引 强制列的值不能为空（NULL），并且该列的值必须唯一。
                    唯一索引 可以包含 NULL 值，多个 NULL 被视为不同的值。
        （3）复合索引：多列值组成一个索引，专门用于组合搜索，其效率大于合并索引
            CREATE INDEX idx_name ON users (first_name, last_name);
                例如，创建一个索引 (A, B)：
                    这个索引能加速查询 A 和 B 的组合条件。
                    也可以加速仅用 A 作为查询条件的情况。
                    但如果查询仅包含 B，则这个索引不能起到作用。
        （4）聚簇索引(聚集索引)：并不是单独的索引类型，而是一种数据储存方式，具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中
            保存了B-Tree索引（技术上来说是B+Tree）和数据行。
                核心概念：
                    1.数据与索引结合存储：
                    数据行和索引是存储在同一个结构中的。也就是说，数据行本身是按照索引的顺序存储的。
                        聚簇索引的叶子节点存储了数据行本身。
                        对于非聚簇索引，叶子节点则存储的是指向数据行的指针。
                    2.B+树结构：
                    InnoDB 为例，聚簇索引使用的是B+树（而不是传统的 B-树）。在 B+树中，所有的数据行都存储在叶子节点，索引节点仅存储索引值以及指向下一层的指针。
                    3.主键索引：
                    聚簇索引通常是基于主键创建的。也就是说，InnoDB 会使用表的主键作为聚簇索引的索引列，数据行会根据主键值来存储。
                    如果表没有主键，InnoDB 会选择一个唯一非空索引作为聚簇索引。如果没有这样的索引，则会创建一个隐式的主键。
                        聚簇索引的优缺点：
                            优点：
                                高效的范围查询：聚簇索引的顺序存储使得范围查询非常高效，避免了额外的 I/O 操作。
                                减少 I/O 操作：对于按主键或其前缀列查询的数据，聚簇索引避免了回表操作，从而提高查询效率。
                            缺点：
                                插入性能问题：由于数据行按主键顺序存储，插入操作可能会导致大量的移动和重新排序
                                更新性能问题：如果更新操作修改了主键或会导致数据行位置变化，这将会影响数据存储顺序
                                只能有一个聚簇索引：一个表只能有一个聚簇索引（通常是主键），这意味着选择合适的主键非常重要。
                        非聚簇索引：如果查询的列没有在索引中（即不在聚簇索引中），MySQL 会通过索引获取行的主键值，然后回表查询整行数据。
                        总结：
                            回表是指通过索引查找数据后，再回到表中查询完整数据的过程。
                            覆盖索引可以避免回表，因为它包含了查询所需的所有字段。
                            回表可能会增加查询的成本，因为需要额外的一次磁盘查找操作。

4.索引的底层实现？
    Hash索引：
            基于哈希表实现，只有精确匹配索引所有的列查询才有效，对于每行数据，存储引擎都会对所有的索引列计算一个哈希码，并且哈希码存储在索引中
        同时在索引表中保存指向每个数据行的指针。
            CREATE INDEX idx_email_hash ON users(email) USING HASH;
        步骤：
            哈希计算：数据库首先计算 'john.doe@example.com' 的哈希值。
            查找哈希表：数据库使用计算出来的哈希值查找哈希表中的桶。
            定位数据行：桶中存储了指向数据行的指针，哈希索引直接提供这个指针，指向实际数据。
            返回结果：通过该指针，数据库访问数据行，读取并返回所有列的值，包括 email 和 age。
        怎么解决哈希冲突？
            哈希冲突一般通过链式哈希或开放地址法解决。链式哈希会在发生冲突时使用链表存储冲突的记录，开放地址法则会在哈希表的其他位置寻找空闲槽位。
    B+Tree索引：
            是B-Tree的改进版本，同时也是数据库索引索引所采用的存储结构。数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。
相比B-Tree来说，进行范围查找时只需要查找两个节点，进行遍历即可。而B-Tree需要获取所有节点，相比之下B+Tree效率更高。

5.为什么索引结构默认使用B+Tree，而不是B-Tree，Hash，二叉树，红黑树？
    B+tree： 从两个方面来回答
        1.B+Tree 的非叶子节点不存储数据，减少了磁盘读取的数据量，适合用于大规模数据集的查找
        2.由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可
    Hash索引：
        1.虽然可以快速定位，但是没有顺序，IO复杂度高；
        2.适合等值查询，如=、in()、<=>，不支持范围查询
        3.因为不是按照索引值顺序存储的，就不能像B+Tree索引一样利用索引完成排序 
        4.因为Hash索引始终索引的所有列的全部内容，所以不支持部分索引列的匹配查找
        5.如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题 
    二叉树：
        树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高
    红黑树：
        树的高度随着数据量增加而增加，IO代价高。

6. 讲一讲聚簇索引与非聚簇索引？
    在 InnoDB 里，索引B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引，即将数据存储与索引放到了一块，找到索引也就找到了数据。
    聚簇索引与非聚簇索引的区别：
       特点	                            聚簇索引	                                            非聚簇索引
     存储结构	             数据存储在索引的叶子节点中，数据按索引顺序排列	         索引存储在独立的结构中，叶子节点存储指向数据的指针
    每个表的数量	               每个表只能有一个聚簇索引	                               每个表可以有多个非聚簇索引
       性能	                  对范围查询有优势，插入、删除和更新较慢	                查询时需要通过索引查找数据，更新较快
     空间占用	              占用较少空间，因为数据本身存储在索引中	               占用更多空间，因为需要存储指向数据的指针
    影响的操作	               插入、删除、更新可能导致数据行的重排	                    插入、删除、更新不会影响数据的物理存储顺序
       对于InnoDB来说，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表。第一次索引一般是顺序IO，回表的操作属于随机IO。需要回表的次数越多，即随机IO次数越多，我们就越倾向于使用全表扫描 
       通常情况下， 主键索引（聚簇索引）查询只会查一次，而非主键索引（非聚簇索引）需要回表查询多次。当然，如果是覆盖索引的话，查一次即可

7. 非聚簇索引一定会回表查询吗？
    不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。一个索引包含（覆盖）所有需要查询字段的值，被称之为"覆盖索引"。

8. 联合索引是什么？为什么需要注意联合索引中的顺序？
    MySQL可以使用多个字段同时建立一个索引，叫做联合索引。
    一般情况下，将查询需求频繁或者字段选择性高的列放在前面。

9. 讲一讲MySQL的最左前缀原则?
    当一个索引包含多个列时，查询条件必须使用索引的最左边的一部分列进行匹配，才能有效利用该索引。
    最左前缀原则要求索引的列顺序必须与查询的条件顺序一致，从左到右逐列匹配才能使用该索引。

10. 讲一讲前缀索引？
    问题：可能我们索引的字段非常长，这既占内存空间，也不利于维护。
        如果只把很长字段的前面的公共部分作为一个索引，目的是在节省存储空间的同时，减少磁盘空间的占用，提升查询效率。
    使用方法：前缀索引的创建方式是通过 CREATE INDEX 语句中的 ( 字段名 ( 前缀长度 ) )进行指定。
        CREATE INDEX idx_email_prefix ON users(email(10));
        这样，MySQL 只会在 email 字段的前 10 个字符上创建索引，而不是整个 255 字符的字段。
      特点	                        描述
    创建方式	    通过指定前缀长度（如 email(10)）来创建前缀索引
    节省空间	    对长文本列（如 VARCHAR、TEXT 类型）节省索引空间
    提升性能	    对于基于字段前几个字符的查询能够提高查询速度
    使用场景	    适用于对长文本字段进行查询，尤其是前缀匹配查询
    注意事项	    选择合适的前缀长度，前缀长度过短或过长都可能影响效率
    不适用的场景	    不适用于完全匹配查询或者字段较小的情况

11. 了解索引下推吗？
    回表的代价比较高，因为它需要两次访问：
        从二级索引中查找匹配的记录（比如找到了某个列的值）。
        然后根据二级索引查到的主键值，再去主键索引查找完整的记录数据。
    索引下推优化指的是，在执行查询时，MySQL 将查询条件（尤其是 WHERE 子句中的条件） 提前推到索引扫描的阶段，而不是等到回表后再做过滤。这能有效减少回表次数。
    在没有索引下推优化时，查询的结果可能是这样的：
        1.通过二级索引获取某些记录的主键值
        2.通过主键索引回表获取完整的记录
        3.在回表结果中，执行where子句的过滤条件
    使用下推优化索引后，查询结果变成：
        1.在二级索引扫描的过程中，直接应用 WHERE 子句中的条件，减少不符合条件的记录（第一步）。
        2.只有符合条件的记录被取出来，回表时，才会访问主键索引（第二步）
    二级索引是 非聚集索引，它们保存的是 索引值 + 主键值 的对，因此需要额外回表查找完整的记录。
    举例：
        第一步：假设我们有一个表 users，包含以下字段：
            id（主键）
            email
            age
        第二步：我们创建了一个二级索引在 email 字段上：
            CREATE INDEX idx_email ON users(email);
        查询语句如下：
            SELECT * FROM users WHERE email = 'alice@example.com' AND age > 30;
        1.如果没有索引下推优化，MySQL 会按如下步骤执行：
            （1）使用二级索引 idx_email 查找所有符合 email = 'alice@example.com' 条件的记录。
            （2）然后，使用回表操作，从主键索引中获取对应的完整记录。
            （3）最后，再对回表的结果应用 age > 30 的过滤条件。
        2.有了索引下推优化 后，查询过程会变为：
            （1）在扫描二级索引时，MySQL 会将 email = 'alice@example.com' 和 age > 30 一起下推到索引层面进行过滤，只有符合这两个条件的记录才会被取出。
            （2）只有符合条件的记录会进行回表操作，减少回表次数。
         数据行本身是按主键的顺序存储在磁盘上的。也就是说，当你使用主键索引进行查询时，返回的数据已经是完整的。


12.怎么查看MySQL语句有没有用到索引？
    使用 EXPLAIN 语句来查看查询是否使用了索引，并且详细了解查询的执行计划
    EXPLAIN 会告诉你查询优化器是如何执行该 SQL 语句的，包括是否使用了索引，索引的选择情况，以及访问表的方式等信息
        使用 EXPLAIN 语句
            你可以在查询语句前加上 EXPLAIN，然后执行查询。比如：
            EXPLAIN SELECT * FROM users WHERE email = 'alice@example.com';
    使用 EXPLAIN 可以帮助你检查 SQL 查询是否使用了索引。
        查看 key 列，如果有索引使用，key 列会显示实际使用的索引名；如果为 NULL，则表示没有使用索引。
        type 列反映了查询的访问方式，ALL 表示全表扫描，ref 或 range 表示使用了索引。

13.为什么官方建议使用自增长主键作为索引？
        结合B+Tree的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。
    总之就是减少分裂和移动的频率。

14.创建索引的三种方式：
    1、CREATE INDEX 语句允许你在已存在的表上创建索引。你需要指定索引名称、表名以及索引列
        语法：CREATE INDEX index_name ON table_name (column_name);
        示例：CREATE INDEX idx_email ON users (email);
    2、使用 ALTER TABLE 语句来添加索引。与 CREATE INDEX 不同，ALTER TABLE 允许你在修改表结构时同时添加索引。
        语法：ALTER TABLE table_name ADD INDEX index_name (column_name);
        示例：ALTER TABLE users ADD INDEX idx_email (email);
    3、创建新表时，可以直接在 CREATE TABLE 语句中定义索引。这是创建表时最简便的一种方法，可以在表的创建过程中同时定义索引。
        语法：CREATE TABLE table_name (
                column1 datatype,
                column2 datatype,
                ...,
                INDEX index_name (column_name)
            );
        示例：CREATE TABLE users (
            id INT AUTO_INCREMENT PRIMARY KEY,
            name VARCHAR(100),
            email VARCHAR(100),
            INDEX idx_email (email)
        );
        在创建 users 表的同时，直接在 email 列上创建了一个索引。

    总结：  
        1、CREATE INDEX：在已存在的表上创建索引。
        2、ALTER TABLE：在修改表结构时添加索引。
        3、CREATE TABLE：在创建表时直接定义索引。

15.创建索引时需要注意什么？
    1、非空字段：应该指定列为NOT NULL，在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；
    2、取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；
        使用 COUNT(DISTINCT) 检查字段的离散程度（选择性），帮助你确定哪些字段的唯一值更多、分布更广。
        在创建联合索引时，将选择性高、离散程度大的字段放在索引的前面，以提高查询性能。
        通过合理的字段顺序优化联合索引，可以显著提高查询效率，减少数据库的扫描范围。
    选择性高的字段意味着该字段有大量不同的唯一值，那么通过索引在查询时，可以迅速定位到目标记录，减少扫描的行数。
    3、索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。
        （1）在数据库中，数据存储是以“页”（Page）为单位进行的。数据库通过固定大小的页面来管理磁盘上的数据（如 MySQL 默认的 InnoDB 引擎中，页面大小通常是 16KB）
            当你查询数据时，数据库会尽量一次性将包含查询数据的页面加载到内存中。
        如果一个索引字段较小，每个索引条目所占的空间就相对较小，这意味着：
            每个页面能够存储更多的索引条目。
            在执行查询时，数据库能通过一次 I/O 操作读取到更多的索引条目。
        这可以显著减少磁盘访问的次数，从而提高查询效率。
        （2）数据库的索引是一个数据结构（通常是 B 树或 B+ 树），其中每个索引条目都包含：
            键值（Key）：即索引字段的值；
            指针（Pointer）：指向数据记录的位置，或者对于覆盖索引，指向实际的数据。
        假设有两种索引字段：
            小字段：比如 int(4) 类型（占用 4 字节），每个索引条目需要 4 字节（键值）+ 8 字节（指针）= 12 字节。
            大字段：比如 varchar(255) 类型（假设最大需要 255 字节），每个索引条目需要 255 字节（键值）+ 8 字节（指针）= 263 字节。
            对于小字段的索引，数据库每一页可以存储更多的索引条目，减少了磁盘 I/O 的次数。
                索引字段越小，通常能提供更好的查询效率，原因如下：
                    （1）小字段索引条目占用空间少，每个页面能存储更多的条目。
                    （2）减少了每次查询所需的 I/O 操作，提高了查询性能。
                    （3）小字段有助于提高数据库缓存命中率，减少磁盘访问。

16.创建索引的原则有哪些？
    1、选择性高的列、经常用于查询条件的列 是索引的最佳候选者。
    2、复合索引 可以提高复杂查询的效率，但要注意索引列的顺序。
    3、避免在低选择性列 和 经常更新的列 上创建索引，以减少不必要的性能开销。
    4、使用覆盖索引 可以减少回表，提高查询性能。
    5、控制索引的数量，避免过多的索引影响数据的写操作性能。

17. 使用索引查询一定能提高查询的性能吗？
    通常通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。
    （1）索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的I* NSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。
    （2）因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:
            基于一个范围的检索，一般查询返回结果集小于表中记录数的30%。
            基于非唯一性索引的检索。
    1. 索引维护的开销
        举例：假设一个表有 5 个索引，每次插入一条新记录，数据库不仅要把数据插入表中，还需要同时更新这 5 个索引。这意味着 5 次额外的磁盘写入和索引更新操作，造成额外的性能消耗。
    2. 增加磁盘 I/O
        索引通常会存储在硬盘上，每次更新索引时，数据库需要读取和写入磁盘。
        对每个索引的更新都意味着一次额外的磁盘 I/O 操作。在大量写操作的情况下，过多的索引会导致磁盘 I/O 压力增大，降低整体性能。
    3. 更新操作的复杂度
        对于 UPDATE 操作，如果更新的字段是索引列，数据库不仅需要更新数据本身，还需要调整索引中的对应记录。
        例如，如果更新了一个有索引的字段，数据库需要删除索引中的旧记录，并插入新的索引记录。
    4. 锁争用问题
        在多用户并发操作的环境中，更新索引会引发锁竞争。例如，多个事务同时进行写操作时，索引的更新可能需要加锁，影响其他事务的并发性。
        索引越多，锁争用的情况就越严重，可能导致写操作的延迟或阻塞，从而影响数据库的整体吞吐量。

18.如何平衡写操作和查询性能：
    1、选择性高的字段：将索引放在选择性高的字段上，以最大化查询性能。
    2、复合索引：尽量通过复合索引来减少单列索引的数量，复合索引能够同时覆盖多个查询条件，避免为每个字段单独创建索引。
    3、定期维护：定期对数据库进行索引优化和清理，删除那些不再使用的索引，避免索引数量的膨胀。

19.优化锁竞争问题
    1. 使用合适的锁粒度
        行级锁（Row-level Locking）：确保数据库使用行级锁而不是表级锁。行级锁能够在更细粒度上控制并发访问，减少多个事务之间的锁争用。
        死锁检测与预防：配置数据库的死锁检测机制。数据库会自动检测事务是否发生死锁，并采取回滚某些事务来避免死锁。
        避免长时间持有锁：确保事务的持锁时间尽量短，避免在事务中做大量计算或I/O操作，减少锁竞争。
    2. 合理选择索引类型
        B+树索引优化：对于常见的事务操作，可以考虑调整 B+ 树索引的参数。增大页大小，以减少磁盘 I/O 操作，降低竞争的发生概率。
        避免非必要的索引更新：对于一些写操作频繁但查询不频繁的列，尽量不要创建索引，或者使用覆盖索引（包含查询字段的复合索引），减少额外索引的维护开销。
    3.异步处理与队列
        延迟更新：对于某些不需要实时更新的操作，可以考虑将更新任务异步化。使用消息队列（如 Kafka、RabbitMQ 等）将写请求推送到队列中，再由后台服务批量处理，这样可以减少直接在数据库上发生的并发写操作。
        延迟索引更新：对于不需要实时维护的索引，可以使用延迟更新机制。例如，在高并发情况下，可以先完成数据更新，后续通过后台异步任务批量更新索引。

20.什么情况下不走索引（索引失效）？
    1.查询条件使用了不适合索引的操作符 
    （1）LIKE 模糊查询：如果 LIKE 查询以 % 开头，数据库无法使用索引进行优化。例如
        SELECT * FROM users WHERE name LIKE '%John%';
    （2）函数操作：在查询条件中使用了函数（如 LOWER(), UPPER(), ABS(), YEAR() 等），会导致索引失效。因为索引通常是基于列的原始值，而使用函数后无法直接匹配索引值。例如：
        SELECT * FROM employees WHERE LOWER(name) = 'john';
    （3）算术运算：在查询条件中对索引列进行算术运算，索引可能会失效。例如：
        SELECT * FROM products WHERE price + 10 = 100;
    2. 不适用的 OR 条件
        OR 连接条件：当查询包含多个条件并且这些条件使用 OR 连接时，如果这些条件涉及不同的列，或者只有部分条件能使用索引时，数据库通常会选择不使用索引，或者会使用部分索引（可能导致效率低下）
        SELECT * FROM orders WHERE status = 'shipped' OR price > 100;
        如果 status 列有索引，price 列有索引，但 OR 会使得数据库不能高效地使用这些索引。
    3. NULL 值的查询
        查询包含 IS NULL 或 IS NOT NULL：索引在某些情况下对 NULL 值的查询支持不好。例如：
        SELECT * FROM employees WHERE hire_date IS NULL;
        由于索引在 NULL 值的匹配上没有优化，可能导致索引失效。
    4. NOT 操作符
        使用 NOT 条件：如果查询包含 NOT 或 NOT IN，可能会导致索引失效。例如：
        SELECT * FROM products WHERE NOT category = 'electronics';
        使用 NOT 会使得索引失效，数据库会选择全表扫描
    5. 不合适的数据类型比较
        类型不匹配：如果查询的条件和列的数据类型不一致，数据库可能无法使用索引。
        SELECT * FROM products WHERE price = '100';
        如果 price 列是数字类型，而查询条件是字符串，数据库可能无法使用索引。
    6. 索引列上有隐式转换
        隐式类型转换：有时，查询中会隐式地将一个列与另一个类型的值进行比较，这种隐式转换可能会导致索引失效。例如：
        SELECT * FROM orders WHERE order_date = '2024-01-01';
        如果 order_date 列是 DATE 类型，而查询条件是字符串类型的 '2024-01-01'，则可能导致类型转换，从而使得索引无法被利用。
    7. 索引覆盖列不完全
        查询字段不在索引中：索引的覆盖性决定了它能否被用于查询。如果查询的列不在索引的定义中，数据库就不能使用索引。例如：
        SELECT id, name FROM users WHERE age = 30;
        如果 age 列没有索引，那么即使 id 和 name 有索引，索引也不会被使用
        
        如何避免索引失效？
            （1）确保查询条件与索引一致：尽量避免在查询条件中使用函数、运算符和 OR。
            （2）避免不必要的类型转换：确保查询条件的类型与表中的列类型一致。
            （3）创建合适的复合索引：根据查询的常见模式创建复合索引，而不仅仅是单列索引。
            （4）使用适当的查询结构：避免过于复杂的查询，确保查询条件与索引匹配。
