一.内存存在的问题：
    1.内存不足：如果是逻辑内存直接映射到物理内存，当逻辑内存超过物理内存的时候，计算机就会出现内存不足的情况，导致程序崩溃。
    2.内存碎片化：如果程序频率启动或退出，会产生内存碎片，对于连续分配内存时，即使碎片内存数量比申请的内存大，但可能导致申请失败，因为没有足够的连续内存。
    3.程序间互相修改内存：如果程序切换时，不同的程序指向相同的内存时，会导致修改数据错乱。
解决以上问题的方案：虚拟内存

二.问题：
    1.假如内存不足会怎么样？
    内存不足,超出内存空间会导致崩溃
    2. 内存碎片化
    如果连续分配内存，程序可能找不到合适的空间(run out of space)，即使有空间，但是不连续
    3. 多个程序指向相同的地址
    不同程序间读写相同的内容，导致数据污染或崩溃
怎么解决？让每一个程序拥有自己的虚拟内存空间。把程序的内存空间映射到物理内存

三.什么是虚拟内存？
如果没有虚拟内存时，程序地址直接映射到物理内存。假如内存为1G,程序A运行时占用了1GB,此时再启动程序B时，发现没有内存空间可用，就导致崩溃。
    虚拟内存:通过Map来查找程序地址对应的物理内存地址。
虚拟内存是怎么解决上述3个问题的呢？
    1、内存不足时:当向系统申请内存但内存不足时，系统会把根据置换算法把暂进不用的内存置换到硬盘里,更新映射关系到硬盘上，再更新新申请的内存映射关系，让我们产生无限内存的错觉。
        (交换到硬盘后会导致性能下降，硬盘读取速度比内存慢太多了)。
    2、内存碎片:程序通过自身的映射表可以随意找到合适的物理内存,而不一定需要连续分配。
    3、 程序间相同的地址:即使程序的地址相同，但是每个程序通过自己的映射表映射到不同的物理内存而不会互相产生干扰。

四、 虚拟内存的原理
    虚拟内存（Virtual Memory）是操作系统提供的一种内存管理技术，它使得应用程序能够认为自己拥有连续的内存地址空间，而实际上，程序的数据可能分布在物理内存和硬盘存储的不同位置。虚拟内存的主要目的是提供一种抽象层，
    使得每个程序都能拥有一个独立的内存空间，从而隔离不同程序的内存，提升内存使用的灵活性与效率。

关于malloc和free内存的问题
    malloc为系统函数，不是系统调用名
背景：
	1.进程虚拟内存空间分布。
	2.从低地址往高地址：
		（1）代码段 ：二进制可执行代码
		（2）已初始化的数据段 ：静态常量
		（3）未初始化的数据段 ：未初始化的静态变量
		（4）堆栈：从低地址往高地址（动态分配）
		（5）文件映射段：动态库 共享内存等
		（6）栈段：从高地址往低地址 （局部变量和局部调用上下文等）
		（7）内核空间
	3.分配的虚拟内存
	4.使用时才会分配真实的物理内存，通过缺页异常分配
如何分配：
	跟上所述息息相关，如果分配的内存小于128K，通过brk系统调用在堆栈当中分配内存。
        缺点：容易产生内存碎片。
    1.方向：堆栈增长方向从低到高 
    2.优先从内存池分配，如果内存池没有可分配的空间，才会调用brk系统调用 
    3.作用.(1)减少系统调用的次数。（2）减少缺页异常的次数（因为内存池的缺页异常还在）
	如果大于等于128K，通过mmap系统调用在文件映射段分配内存

free释放内存，内存还在吗？
	1.如果小于128k  brk分配的内存会回归到内存值当中去
	2.如果是通过mmap系统调用，则会立即归还到操作系统

怎么知道该释放多少内存：
	malloc每次去分配空间的时候，都会多要16个字节。16字节用来记录它的长度信息，内存块的大小，还会记录内存块其他的描述信息。
	就如 在释放的时候，指针会左偏移16位，就知道自己释放的内存有多大。

注意：在分配的时候不是立马就会有物理内存，只有在使用的时候他才会分配。
怎么分配：虚拟内存空间到物理内存空间中间有一个页表，通过页表去找这个物理空间的地址，它没有的时候会触发缺页异常，缺页异常就会在物理地址空间，去建立映射关系，在缺页异常当中，
    去建立虚拟内存跟物理内存的映射关系，页表会记录映射关系。