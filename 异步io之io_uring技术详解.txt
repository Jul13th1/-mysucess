异步io之io_uring技术详解，与epoll有什么区别？

一、io_uring 概述
    io_uring 是 Linux 内核中的一种高效异步 I/O 框架，于 Linux 5.1 版本引入，旨在提高大规模并发 I/O 操作的性能。与传统的异步 I/O 接口（如 epoll、select、poll）相比，io_uring 提供了更低的延迟和更高的吞吐量。
二、核心概念
1.提交队列（Submission Queue, SQ）：
    用户空间应用程序将 I/O 请求添加到提交队列中。每个请求都会被描述为一个提交队列条目（Submission Queue Entry, SQE），包含操作类型、目标文件描述符、缓冲区等信息。
2.完成队列（Completion Queue, CQ）：
    当 I/O 操作完成时，内核会将结果添加到完成队列中。每个结果都是一个完成队列条目（Completion Queue Entry, CQE），其中包含了操作的返回值、状态码以及用户自定义的数据。
3.异步操作：
    io_uring 允许用户将 I/O 操作提交给内核，内核在后台异步处理这些操作。用户不需要等待操作完成，而是可以在稍后查询完成队列以获取操作结果。
三、主要系统调用
1. io_uring_setup
    功能：
        io_uring_setup 是用于创建和初始化一个 io_uring 实例的系统调用。它分配和配置提交队列（SQ）和完成队列（CQ），并返回一个用于标识 io_uring 实例的文件描述符。
    依赖函数：
        io_uring_queue_init：io_uring_queue_init 是最常用的初始化函数，内部调用 io_uring_setup 来创建一个 io_uring 实例。
        io_uring_queue_init_params：io_uring_queue_init_params 是一个增强的初始化函数，它允许用户传递 io_uring_params结构体以配置额外的参数。它也依赖于io_uring_setup系统调用来创建和初始化io_uring实例。
2. io_uring_enter
    功能：
        io_uring_enter 是用于将已准备好的 I/O 操作提交给内核并处理这些操作的系统调用。它可以用于提交操作、等待操作完成，或者两者兼而有之。
    依赖函数：
        io_uring_submit：io_uring_submit 是用户提交操作到内核的函数，它在内部调用 io_uring_enter，将所有在提交队列中的 I/O 请求提交给内核。
        io_uring_submit_and_wait：io_uring_submit_and_wait 提交 I/O 操作后，还可以等待至少一个操作完成，它也是通过调用 io_uring_enter 来实现这一功能。
        io_uring_wait_cqe和io_uring_wait_cqe_nr：这些函数用于等待一个或多个操作完成，它们在内部也依赖于 io_uring_enter，通过传递适当的参数来等待完成队列中的事件。
四、常用操作
io_uring_prep_* 系列函数：
    用于准备 I/O 操作，如 io_uring_prep_read、io_uring_prep_write、io_uring_prep_accept、io_uring_prep_send 等。这些函数将操作的细节填写到提交队列条目（SQE）中。
io_uring_submit：
    将准备好的 SQE 提交给内核，触发内核执行操作，内部依赖 io_uring_enter 系统调用。
io_uring_wait_cqe与io_uring_peek_batch_cqe：
io_uring_wait_cqe：阻塞等待至少一个操作完成，并返回完成的 CQE。
io_uring_peek_batch_cqe：非阻塞地检查完成队列，获取已经完成的操作。
五、优势
    减少系统调用开销：通过批量提交和批量获取结果，减少了系统调用的次数，降低了上下文切换的开销。
    高效的异步操作：内核异步处理 I/O 操作，用户空间无需阻塞等待，可以在处理其他任务的同时等待操作完成。
    灵活的事件模型：io_uring 支持多种 I/O 操作，并可以在不同的操作之间灵活切换，适用于网络 I/O、文件 I/O、内存映射等多种场景。
    扩展性强：io_uring 支持大量并发的 I/O 操作，适合需要处理高并发连接的应用程序，如高性能服务器和数据库。

六. io_uring和传统的eopll对比
    io_uring 和传统的 epoll 都是 Linux 下用于处理 I/O 事件的机制，但它们的设计目标、性能和使用场景有显著差异。
1. 基本概念
    epoll：
        epoll 是 Linux 提供的一个用于处理大规模文件描述符集合的 I/O 多路复用机制。它主要通过事件驱动的方式，监控文件描述符的 I/O 状态变化（如可读、可写等），当这些文件描述符准备好时，epoll 会通知应用程序。
    io_uring：
        io_uring 是一个较新的异步 I/O 接口，旨在通过减少内核与用户空间之间的交互，提高 I/O 操作的效率。与 epoll 的事件驱动方式不同，io_uring 提供了一种更加高效的异步 I/O 提交和完成机制，使用共享的内存缓冲区进行数据传输，减少了内核态和用户态之间的上下文切换。

2. 工作机制
    epoll：
        事件驱动：epoll 基于事件通知机制。应用程序通过 epoll_create 创建一个 epoll 实例，然后通过 epoll_ctl 向 epoll 实例中注册文件描述符。当文件描述符准备好进行 I/O 操作时，内核会将其状态通过 epoll_wait 通知应用程序。
        阻塞/非阻塞：epoll 本身是阻塞的，即它会阻塞在 epoll_wait 调用上，直到一个或多个事件发生。可以通过 epoll_ctl 注册文件描述符的 I/O 事件（如可读、可写等）。
    io_uring：
        提交和完成队列：io_uring 采用了**提交队列（Submission Queue, SQ）和完成队列（Completion Queue, CQ）**的模型。应用程序将 I/O 操作提交到提交队列，然后内核执行操作，并将结果放入完成队列。应用程序通过轮询完成队列来获取操作结果。
        高效的异步 I/O：io_uring 减少了内核和用户空间之间的上下文切换，通过使用共享内存区域（环形缓冲区）来实现高效的数据传输和操作提交，避免了传统的系统调用开销。

3. 性能对比
    epoll 性能：
        epoll 是一种同步机制，应用程序需要定期轮询事件，通过 epoll_wait 来检测 I/O 操作是否就绪。虽然 epoll 在处理大量并发连接时表现良好，但它的效率会受到内核与用户空间之间上下文切换的影响，尤其是在高负载下。
        性能瓶颈：epoll 需要通过系统调用和事件轮询来获取每个文件描述符的状态，对于每次事件发生都需要执行一次系统调用，这可能导致一定的性能开销。
    io_uring 性能：
        io_uring 提供了更高效的 I/O 提交和完成机制，显著减少了上下文切换和系统调用的开销。由于 io_uring 直接使用共享内存进行数据传输，它可以在用户空间和内核空间之间高效地交换数据。
        零拷贝：io_uring 支持零拷贝技术，减少了内存复制的开销，提升了数据传输效率。
        异步操作：io_uring 的异步 I/O 提交方式比 epoll 更加高效，特别是在需要大量并发 I/O 操作的场景下，它能够减少等待 I/O 完成的时间，提高整体吞吐量。

4. 编程模型
    epoll 编程模型：
        epoll 基于事件驱动，开发者通常需要在应用程序中实现事件循环。使用 epoll 时，开发者需要管理多个文件描述符并等待事件的发生。
        对于每个事件，应用程序必须调用 epoll_wait 来获取事件信息，进而执行相应的 I/O 操作。
        epoll 编程模式相对简单，但在高并发环境下可能会受到性能瓶颈的影响，尤其是在每次事件发生时都需要调用系统调用。
    io_uring 编程模型：
        io_uring 提供了更低层次的接口，开发者需要管理提交队列和完成队列。应用程序需要通过共享内存提交 I/O 请求，并使用轮询或通知机制等待操作完成。
        io_uring 允许开发者将 I/O 操作分批提交，大大减少了内核和用户空间之间的交互次数。
        io_uring 的编程模型更复杂，但能够在高性能应用中提供显著的性能优势。

5. 支持的功能
    epoll 支持的功能：
        主要用于处理文件描述符的 I/O 事件，支持 EPOLLIN（可读事件）、EPOLLOUT（可写事件）等事件类型。还支持 EPOLLERR（错误事件）、EPOLLHUP（挂起事件）等状态。
        epoll 适用于处理高并发的文件描述符，特别是网络连接的 I/O 事件。
    io_uring 支持的功能：
        除了支持传统的文件 I/O 操作外，io_uring 还支持更广泛的操作，如 文件读写、网络 I/O、内存映射 I/O、AIO (异步 I/O) 等。
        io_uring 还支持多种 I/O 操作的批量提交，可以进一步提高性能。
        它还支持提交 I/O 操作的同时进行其他异步任务，比如提交多个 I/O 请求，并在同一时刻等待不同请求的完成，支持更复杂的 I/O 模式。

6. 适用场景
    epoll：
        epoll 更适合于传统的事件驱动模型，适用于大量短时间内发生的 I/O 操作（例如，大量的网络请求）。它通常用于服务器端应用（如 Web 服务器、数据库等）中，处理多个并发连接。
        适用于低负载、I/O 事件较少的场景。
    io_uring：
        io_uring 更适合于需要高并发和低延迟的场景，如高频交易、大数据流处理、分布式存储、数据库系统等。
        特别适合对性能要求较高、需要大规模并发 I/O 操作的应用，如高性能网络服务器、虚拟化存储、大规模数据处理等。
7.总结对比：
    特性	                        epoll	                                  io_uring
    模型	                    基于事件驱动（同步）	                    基于提交和完成队列（异步）
    性能	             适合中低并发，但会受到上下文切换影响	        高并发、大吞吐量，减少上下文切换，提高性能
    复杂度	               编程简单，适用于基本的事件驱动应用	                编程复杂，适合高性能应用
    支持的操作	           文件描述符事件通知，主要是 I/O 操作	         支持多种 I/O 操作（文件、网络、内存映射等）
    零拷贝	                        不直接支持零拷贝	                           支持零拷贝
    适用场景	              中低并发应用（如 Web 服务器）	        高并发、大吞吐量、高性能应用（如数据库、存储）

七、问题与思考
    1、提交队列肯定需要多线程操作，是否需要加锁？
        对于io_uring的提交队列来说，在多线程操作下不需要加锁。io_uring使用了无锁环形队列，通过原子操作来管理队列的头尾指针，确保多个线程可以安全且高效地并发提交I/O请求。
    这种设计避免了传统锁的开销，尤其适合高并发场景下的性能优化。
        无锁环形队列的原理：
        1.环形缓冲区：
            环形队列是一种常用的数据结构，其中队列的头和尾指针在到达缓冲区末尾时回绕到开始开始位置，从而形成了一个环
            在io_uring 中，提交队列和完成队列实际上是一个环形缓冲区，允许多个线程高效地提交和消费I/O操作。
        2.原子操作：
            无锁设计的关键在于使用原子操作来管理队列指针，确保即使在多线程环境下，多个线程同时访问队列时也不会产生竞争条件。
            io_uring 使用原子性操作（例如 cmpxchg 或 fetch_add）来更新队列的头尾指针，从而避免了锁的使用。
        3.多生产者/多消费者支持:
            io_uring 的设计支持多生产者（即多个线程提交I/O请求）和多消费者（即多个线程处理I/O完成事件）。在这种模式下，通过原子操作，多个线程可以无锁地同时对提交队列或完成队列进行操作。
    
    2.io_uring如何避免频繁的拷贝的？
        io_uring 的实现旨在通过减少用户空间和内核空间之间的数据复制来提高 I/O 操作的性能。虽然io_uring并不是直接依赖于mmap来避免拷贝，但它使用了多种技术和机制来减少不必要的数据复制和系统资源消耗。
        io_uring 的关键机制：
        1.提交队列和完成队列（SQ 和 CQ）：
                io_uring 使用了两个环形队列：提交队列（Submission Queue, SQ）和完成队列（Completion Queue, CQ）。用户空间通过 SQ 提交 I/O 请求，而内核通过 CQ 返回操作的完成状态。
            这两个队列都可以通过 mmap 映射到用户空间，允许用户空间直接操作这些队列，减少了系统调用的频率。
        2.直接提交和批量处理：
                用户空间可以将多个 I/O 请求直接写入 SQ，然后通过一个系统调用将它们提交给内核。内核可以批量处理这些请求，并将结果写入 CQ。这减少了频繁的系统调用和数据拷贝。
        3.注册固定缓冲区和文件描述符：
                io_uring 允许用户提前注册缓冲区和文件描述符，这些缓冲区和文件描述符在后续的 I/O 操作中可以被重复使用。由于这些资源已经预先注册并映射到内核，因此在实际的 I/O 操作中不需要再次传递和复制这些资源。
        4.直接 I/O 支持：
                io_uring 可以与直接 I/O（Direct I/O）结合使用，使得数据可以直接从用户空间传输到存储设备或网络设备，或者从设备直接读取到用户空间，绕过内核缓冲区。这进一步减少了内核空间和用户空间之间的数据拷贝。
        5.零拷贝发送和接收：
                在网络传输中，io_uring 支持零拷贝发送和接收，特别是在高性能网络应用中，这意味着数据可以直接从用户空间传输到网络栈，而不需要在内核缓冲区和用户缓冲区之间进行拷贝。
        实现细节：
            内存映射（mmap）：SQ 和 CQ 通常会通过 mmap 映射到用户空间，这样用户空间可以直接访问这些队列的数据结构。这不仅减少了系统调用的开销，也避免了在用户空间和内核空间之间的数据复制。
            原子操作和无锁队列：在多线程环境下，io_uring 使用原子操作来管理队列的头和尾指针，从而避免了锁的使用，进一步提高了性能
            批量提交与处理：io_uring 支持批量提交 I/O 请求，允许多个请求在一次系统调用中被提交到内核。这种机制减少了系统调用的次数，并且通过批量处理可以减少内核空间与用户空间之间的数据交换。
        总结：
            io_uring 通过设计高效的提交和完成队列、支持直接 I/O 和零拷贝技术，
            允许注册和重用缓冲区来避免频繁的数据复制。这种设计使得 io_uring 在处理大规模异步 I/O 操作时，能够提供极高的性能和低延迟。

    3.当服务器通过listen函数开始监听端口时，程序会阻塞在哪里？
        阻塞点的分析：
            在程序运行后，当服务器通过 listen 函数开始监听端口时，它并不会立即处理任何连接请求，而是等待客户端连接的到来。在这期间，程序的执行流会阻塞在某些地方，具体来说，它阻塞在两个可能的地方：
            1、io_uring_wait_cqe(&ring, &cqe);
                    这个调用是 io_uring 的一个重要部分，它用于等待完成队列（CQE）中至少有一个事件完成。在没有事件发生的情况下，比如没有客户端发起连接请求时，这个函数会阻塞，直到有新的事件到达为止。
                因此，如果没有客户端连接请求，程序会阻塞在这里。
            2.io_uring_peek_batch_cqe(&ring, cqes, 128);
                    这个函数用于检查 io_uring 完成队列中是否有已完成的事件。虽然它本身并不阻塞，但在 io_uring_wait_cqe 解除了阻塞之后，这个函数会获取已经完成的事件列表并处理它们。
        重点总结：
            阻塞点：程序在没有客户端连接请求时，会阻塞在 io_uring_wait_cqe函数上，等待 io_uring 完成队列中的事件。
            异步处理：一旦有事件完成（例如客户端连接到来），程序会解除阻塞并处理该事件，接着继续等待下一个事件的完成。
    
    4.io_Uring和epoll有什么相同点和区别？
        相同点：
            1.高并发I/O处理：两者都旨在高效处理大量并发I/O操作，特别是在网络服务器等需要处理众多客户端连接的场景中。
            2.事件驱动模型：两者都采用事件驱动的模型，程序通过等待I/O事件发生然后进行相应处理，避免了轮询的低效性。
            3.减少阻塞：epoll 和 io_uring 都通过异步或非阻塞的方式减少了I/O操作中的等待时间，提高了应用程序的响应速度和整体性能。
        区别：  
            1.设计与用途：
            epoll：
                epoll 是基于 poll 和 select 的改进版，专门用于监控多个文件描述符（socket、文件等）的事件（如读、写、异常等）。
                它本身并不执行I/O操作，而是等待并通知I/O事件的发生。
                epoll 适合事件驱动的网络编程，例如监视多个客户端连接的服务器。
            io_uring：
                io_uring 是一个更广泛的异步I/O框架，它不仅仅用于事件通知，还直接执行I/O操作。
                支持文件读写、网络I/O等操作，并且设计上避免了频繁的上下文切换和数据复制。
                io_uring 适合需要处理大量I/O操作的高性能应用，例如高吞吐量的服务器、数据库系统等。
            2.系统调用的数量与性能：
                epoll：
                    使用时需要多次系统调用。例如，你需要用 epoll_ctl 注册或修改事件，再用 epoll_wait 等待事件发生。
                    每次等待事件都需要从用户空间切换到内核空间，尽管 epoll 的性能比 select 和 poll 高，但频繁的系统调用仍然是一个瓶颈。
                io_uring：
                    通过提交和完成队列（SQ和CQ）机制，大大减少了系统调用的数量。你可以批量提交多个I/O操作，然后一次性等待它们的完成。
                    io_uring 利用共享内存区域在用户空间和内核空间之间传递I/O请求和结果，减少了上下文切换和系统调用开销，性能优势明显。
            3.I/O操作类型的支持：
                epoll：
                    主要用于监听和处理文件描述符上的事件，不直接执行I/O操作。
                    你可以监控 EPOLLIN、EPOLLOUT 等事件，但具体的I/O操作仍需由用户代码完成。
                io_uring：
                    不仅可以处理事件通知，还可以直接执行I/O操作（如读写文件、网络I/O）。
                    支持零拷贝传输、固定缓冲区等高级功能，适合需要高效I/O处理的复杂场景。
            4.阻塞与非阻塞：
                epoll：
                    epoll_wait 可以设置为阻塞或非阻塞模式，通常情况下会阻塞直到有事件发生。
                io_uring：
                    io_uring 支持完全异步的操作，通过提交和完成队列的机制实现了非阻塞I/O。
                    可以同时处理多个I/O操作并等待它们的完成，无需像 epoll 那样分别等待每个事件的发生。
            5.开发复杂度：
                epoll：
                    相对来说更简单，只需关注文件描述符的事件注册和处理。
                io_uring：
                    功能更强大，支持更多操作类型，但开发复杂度较高。需要管理提交队列和完成队列，以及处理可能的错误和资源管理。

原子操作的特点：
    不可分割性：原子操作要么完成，要么不执行，不会被线程调度中断或分割成多个步骤。
    一致性：原子操作在多线程环境下执行时，不会被其他线程干扰，确保执行的结果是完整且一致的。
    不可打断性：在执行原子操作的过程中，其他线程不能插入或修改操作过程，它对外部不可见。
