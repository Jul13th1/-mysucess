1.线程池的作用？
    主要作用：避免创建过多的线程时引发的内存溢出问题，因为创建线程是非常耗内存的
    1.降低资源消耗：通过重复利用已创建的线程减低线程创建和销毁造成的消耗。
    2.调高响应速度：当任务到达时，任务可以不需要等待线程创建就能立即执行
    3.提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。
    如果线程的并发数量过多，线程之间抢占所属进程资源的情况就很严重，容易导致阻塞，使用线程池能有效的控制线程的最大并发数，有效避免阻塞问题。
    什么时候使用线程池？
        a.单个任务处理时间较短
        b.需要处理的任务数量大
    什么时候不适宜用线程池？
        a.线程执行需要很长的时间
        b.需要为线程指定详细的优先级，因为线程池都是基于任务队列来排队，先来先执行
        c.在执行线程中需要对线程进行操作，比如睡眠挂起等，因为线程池本身就是为了突然大量爆发的短任务而设计

2.如何实现线程池？
    1.创建线程池控制结构的结构体
    2.初始化线程池：
        线程池空间开辟+信息初始化+初始化互斥锁和条件变量+创建线程
    3.向线程池的任务队列中添加一个任务：
        上锁+判断线程池状态（队列满的时候就等待、队列关闭或者线程池关闭就退出、队列空的时候，有任务来时就通知线程池中的线程）+解锁
    4.任务执行（回调函数）
        上锁+判断线程池状态（队列为空时就等待、线程池关闭就退出、队列非满：添加新任务、队列为空：销毁线程函数）+解锁+线程真正要做的工作，回调函数的调用。

3.聊天室的服务器框架？
    主线程监听socket之后，进入无限循环调用accept处理客户端的连接，accept返回新的客户端socket后封装任务交给线程池处理，线程池的线程共用一个队列
    当有任务产生时，从任务队列中取出执行。
问题：
4.主线程如何通知工作线程有任务？
    使用条件变量，并且每次只唤醒一个工作线程
5.C++使用线程池时，假设某次投递了N个任务，想同时唤醒N个线程（N小于工作线程数目），这样如何设计？
    1.使用std::queue来储存任务
    2.线程池：使用 std::vector<std::thread> 来存储工作线程，线程池的线程数大于 N
    3.条件变量：用于线程之间的同步和唤醒。
    4，任务调度：在投递任务时，通过条件变量和任务计数器来控制唤醒 N 个线程

6.如果 accept 之后就将客户端 socket 封装成任务交给线程池处理，此时严格来说是没有任务需要执行的，因为客户端 socket 上不一定有数据需要收发，如果有数据需要收发，
任务线程如何处理？如果在工作线程中将客户端 socket 挂载到某 IO 复用函数上去，那么为了保证效率，这些任务就常驻线程池了，这样几个连接之后，线程池的所有线程都被占用了，无法继续处理其他任务了
    在accept()后，客户端的socket可能不会立即有数据要发，这时候将socket交给线程池的工作线程，线程可能会处于等待状态，直到有数据可读或者可写
    这种设计的核心是将 IO 复用的事件循环与工作线程池分开。你可以在主线程中使用 IO 复用机制（如 epoll 或 select）来监听所有的客户端 socket。然后，在有可读/可写事件发生时，将相应的任务交给工作线程池处理。
        设计步骤：
        主线程：使用 epoll 或 select 等机制监听所有的 socket（包括新接入的连接）。
        IO 事件通知：当某个 socket 上有可读/可写事件时，主线程将该 socket 和任务封装成一个工作任务。
        提交给线程池：主线程将任务提交给线程池，工作线程会在获取到任务后进行相应的处理。
        工作线程：处理实际的业务逻辑，如读取数据、处理请求并返回响应等。

7.TCP 是流式协议，包头可以通过 \r\n\r\n 确定边界，包体如何确定边界呢？
    固定长度包体：缺点可能需要填充一些无用的数据，以满足固定长度要求。
    长度字段方式：在包头中包含一个字段，指明包体的长度。接收方通过读取包头中的长度信息来确定包体的边界。缺点是需要额外的包头来存储长度信息
    分隔符方式：除了使用 \r\n\r\n 来分隔头部与包体，你也可以使用其他特定的分隔符（如 \0、|、$ 等）来分隔包体的不同部分
    消息边界协议（比如 \n 或 \0）：容易受到数据中出现分隔符的干扰，可能导致解析困难。

8.GET 请求和 POST 请求有什么区别？
    GET 请求：
        目的：GET请求常用于获取资源（如网页、图片、数据等）。它是无副作用的请求，意味着它不会修改服务器上的任何数据
        参数位置：在GET请求中，所有的请求参数都包含在URL中，即URL 后的查询字符串部分（如 ?key1=value1&key2=value2）。这些参数通过 & 符号分隔
        请求体：GET 请求没有请求体，所有数据都放在 URL 中。
        数据长度限制：由于所有数据都在 URL 中，浏览器或服务器对 URL 长度有一定限制（一般是 2048 字符左右），因此 GET 请求适合传递少量数据。
        缓存和历史记录：GET 请求可以被缓存，并且会记录在浏览器的历史记录中。
    POST请求：
        目的：POST 请求通常用于提交数据（如表单数据、文件上传等）到服务器，并可能修改服务器上的数据（例如创建、更新资源）。
        参数位置：POST 请求中的参数不包含在 URL 中，而是放在请求体（body）中。请求体的内容可以是各种格式，如表单数据、JSON、XML 或文件数据。
        请求体：POST 请求有请求体，可以承载大量数据，没有像 GET 请求那样的长度限制
        缓存和历史记录：POST 请求不会被缓存，也不会出现在浏览器的历史记录中。

9.如何区分GET和POST请求？
    在服务器处理请求时，通常会根据 HTTP 请求的 方法 来区分 GET 和 POST 请求。服务器在解析 HTTP 请求时，会检查请求的 Method 字段：
	GET 请求：Method: GET
	POST 请求：Method: POST
     这两种请求方法有不同的处理流程：
	GET 请求：一般直接解析 URL 中的查询参数（query string）。
	POST 请求：解析请求体中的数据。

10. 如何解包 GET 请求和 POST 请求的数据？
    GET请求数据包解包：
        GET 请求的数据通常通过 URL 查询字符串传递，因此解包 GET 请求的数据主要是从 URL 中解析查询字符串。
    POST 请求数据解包：
        POST 请求的数据则通过请求体（body）传递，具体的数据格式取决于 Content-Type 头的值，
        常见的 POST 数据格式有 application/x-www-form-urlencoded、multipart/form-data 和 application/json 等。
        1.application/x-www-form-urlencoded：
	        这种格式通常用于表单数据，数据是键值对的形式，每个键值对由 & 分隔，并且键和值之间使用 = 连接
        2.multipart/form-data：
            这种格式通常用于上传文件，数据会被分割成多个部分，每个部分都有自己的头部信息和内容。每个部分用一个分隔符（boundary）分开。
            服务器解包时，需要根据 boundary 来分割请求体，提取文件内容及表单数据
        3.application/json：
	        当 POST 请求的 Content-Type 为 application/json 时，请求体的内容是一个 JSON 格式的字符串。服务器需要将请求体解析为 JSON 对象。

11.POST 请求的数据放在哪里，如何确定？
    POST 请求的数据存放在请求体（Body）中。
	在 HTTP POST 请求中，数据的长度可以通过 Content-Length 头部来确定。Content-Length 是一个 HTTP 请求头，它表示请求体中数据的字节数。
    它的作用是告知服务器，数据的总长度是多少，服务器可以根据这个长度读取正确数量的字节。

12.服务端需要调用 bind 一个端口号，如果不 bind 会怎样？客户端通常不需要 bind 一个端口号，但是如果调用 connect 函数前，我们调用 bind 函数绑定一个端口号，会怎样？
    如果不调用 bind：
		服务端无法知道通过哪个端口来接收来自客户端的连接请求。
		服务器无法监听和接收数据，因为没有明确的端口来接收客户端连接。
		在实际的程序中，通常在 bind 之后才会调用 listen 或 accept 等函数来处理客户端的连接
    简而言之，服务端必须调用 bind 来绑定端口，才能开始接收来自客户端的连接请求。
	客户端调用 bind 函数绑定端口号
	    客户端通常不需要手动调用 bind，因为在调用 connect 时，操作系统会自动为客户端分配一个本地端口。客户端通常只关心连接到服务端的远程地址和端口，不必关心本地端口的选择。
	    客户端如果显式地调用 bind 绑定了一个端口，它会将本地套接字绑定到指定的端口号上。
        通常情况下，客户端并不需要指定本地端口，因为操作系统会自动选择一个可用端口。
    调用 bind 绑定本地端口对客户端的影响：
        如果客户端明确调用了 bind，它将强制客户端使用指定的端口进行通信。
        如果客户端调用了 bind，它将始终使用指定的端口进行通信，而无论操作系统是否有更合适的端口。
	    如果绑定的端口已经被占用，bind 会失败，返回错误。

13.在C++中实现TCP聊天室的心跳机制时，主要是通过定期发送心跳包来检测客户端与服务器的连接是否仍然有效。以下是几种常见的心跳机制实现方式：
    1.定时发送心跳包： 
        服务器定期向客户端发送心跳包（如“PING”消息），客户端收到后回复心跳响应（如“PONG”）。
        如果在指定时间内没有收到响应，则认为客户端已断开，服务器可以关闭连接。
        客户端同样可以定期向服务器发送心跳，确保连接活跃。
    2.TCP Keep-Alive选项：
        利用操作系统提供的TCP Keep-Alive机制，在空闲连接上定期发送探测包（"TCP Keep-Alive"）。
        如果多次探测未得到响应，连接会被判定为断开。
        该方法由操作系统处理，不需要在应用层编写心跳包发送逻辑。
    3.设置Socket超时：
        设置发送和接收的超时时间，如果客户端或服务器在一定时间内没有接收到数据，可以触发超时处理。
        例如，使用setsockopt设置SO_RCVBUF和SO_RCVBUF超时，检测连接是否中断。

14.TCP/IP协议栈
OSI七层网络模型：
（1）应用层：所有能和用户交互产生网络流量的程序，应用程序使用（主要协议FTP（文件传输）、HTTP、SMTP（电子邮件）））
（2）表示层：文件格式，用于处理在两个通信系统中交换信息的表示方式
（3）会话层：控制发包的数据，向表示层实体/用户进程提供建立连接并在连接上有序的传输数据
（4）传输层：负责主机中两个进程的通信，即端到端的通信 传输单位：报文段和用户数据报
（5）网络层：主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务 传输单位：数据报
（6）数据链路层：主要任务把网络层传下来的数据报组成帧 传输单位：帧
（7）物理层：通信介质的信号的物理信号 传输单位：bit
TCP/IP四层网络模型
（1）应用层：应用之间沟通的层次：FTP、HTTP
（2）传输层：进程和进程之间的通信 TCP UDP
（3）网络层：对数据进行打包传送的层 IP ICMP
（4）链路层：数据帧的发送

大端：高位放低地址
小端：地委放低地址
htonl：将32位主机字节序转成网络字节序
htons：将16位主机序列转成网络序列
udp和tcp区别
一、共同点：都是传输层协议
二、区别：
    1.是否面向连接
    udp：面向无连接的
    （1）无需三次握手，四次挥手
    （2）支持一对一，一对多，多对一，多对多
    tcp：面向连接的
    （1）三次握手建立连接，四次挥手断开连接
    （2）端对端连接
    （3）全双工允许两端同时发数据

    2.数据传输方式：
    udp：
        基于报文传输，在udp这一层不会进行分段，所以每次收发都是完整的报文
    tcp：
        基于字节流
        发送数据到socket的时候，它经过tcp，如果数据大于MSS（MSS代表“最大报文段长度”（Maximum Segment Size），它是TCP连接中可以发送的最大数据量，
        不包括TCP头和IP头。MSS的设置有助于避免在网络中发生分片，提升传输效率，MSS1500减去ip头20减去tcp头20，所以通常大小为1460字节，所以数据包大于
        这个字节的时候，就可能会拆分成多个tcp报文段，不会保留用户层数据包的一个边界，对于接收方而言需要处理粘包问题，怎么处理：用户层会根据根据特殊字符
        界定一个完整的数据包将它取出来），就会进行分段，分段之后，在ip层如果大于MTU还会进行分片
        什么是MTU：MTU代表“最大传输单元”（Maximum Transmission Unit），是指在网络层（如IP层）中，能够通过网络传输的最大数据包大小，包括所有的协议头（如IP头）和数据部分。
    3.是否可靠：
    udp：不可靠传输
    （1）不保证信息交互
    （2）不保证交互顺序
    （3）不进行拥塞控制
    （4）不进行流量控制（没有接收缓冲区）
    tcp：可靠传输
    （1）tcp分段，进行发送数据包的控制
    （2）序列号（每个tcp报文都包含序列号，确保完整接收，丢失重复数据，将拆分的报文进行排序）
            为什么需要序列号：为了后面的数据包确认（确认应答机制）
            为什么三次握手需要随机序列号：防止三次握手前面的连接干扰当前连接的建立
    （3）确认应答机制：确认数据包收到
    （4）校验：检测报文在传输的过程中的数据发生变化
    （5）滑动窗口：主要作用实现流量控制，防止丢包
    （6）拥塞机制：指网络环境发生了拥塞，应该减少数据量的发送（如果忽略拥塞控制，就会一直不断的往这个网络环境中发送数据，可能会造成丢失数据包，从而进行重传）
    （7）超时重传
   4.传输效率：
   udp：效率高
   （1）不可靠传输
   （2）udp头8个字节
   tcp：效率低
   （1）tcp可靠传输，造成性能损失
   （2）tcp头20个字节
        tcp数据段比udp数据段高一些，所以传输效率没有udp高

网络编程问题汇总：
1.127.0.0.1，localhost和本机IP三者的区别？
    127.0.0.1环回地址：流向该地址的数据是不经过网卡的，所以在没有网络的状态下也能产生连接
    localhost 一个域名，通常被指向本地回环地址
    本机 IP 地址就是联网时使用的网卡分配到的 IP 地址。
2.一个完整的HTTP请求过程。
    1.域名解析
    2.发起tcp的三次握手
    3.发起tcp连接后发起http请求
    4.服务器端响应http请求，浏览器得到html代码
    5.浏览器解析html代码，并请求html代码中的资源
    6.浏览器对页面进行渲染呈现给用户
3.GET和POST请求方式的区别：
    GET：                           POST
    后退按钮/刷新无害                 数据会被重新提交
    数据长度限制/URL长度2048字符       长度无限制
    数据可见/安全性差                 不可见/更安全
    可以被缓存                       不可以被缓存

4.客户端端口可以重复使用吗？
    在tcp连接的初始阶段，客户端必须选择一个端口号，用以向服务器发起连接请求，客户端在执行connect函数的时候，会在内涵==内核里随机选择一个端口，
    然后向服务器发起SYN报文，然后与服务器进行三次握手

5.客户端connect服务器，但是ip写错了，会发生什么？
    1.ARP请求（局域网内）：
    如果错误的IP地址被分配到本地局域网内，客户端会首先尝试通过ARP请求获取该IP地址对应的MAC地址
    如果没有设备响应ARP请求，客户端会认为该IP地址在网络中不可达
    2.TCP尝试连接：
    如果客户端使用TCP协议尝试连接，它会开始TCP三次握手过程，发送SYN包。如果错误的IP地址不可达，客户端不会收到预期的SYN-ACK响应。
    客户端会根据 tcp_syn_retries 参数重试发送SYN包。在重试次数耗尽后，客户端会认为连接尝试失败，并向应用程序报告错误，通常是 “Connection timed out”。 

6.accept的作用？
    1.半连接队列：用于存放那些已经完成TCP三次握手的前两个步骤（客户端发送SYN包，服务器回复SYN+ACK包）的连接请求。
                此时处于SYN_RECEIVED状态，但尚未完成第三次握手（客户端发送ACK确认）。
        作用：服务器通过维护这样的一个队列来跟踪等待完成握手的连接，确保不会因为短时间内大量连接请求而丢失或混淆
    2.全连接队列：全连接队列是指那些已经完成了TCP三次握手，即客户端发出了最后一个ACK包确认，
                但服务器还未通过accept()系统调用将其取出并分配给进程处理的连接。这些连接的状态为ESTABLISHED。
        作用：这个队列保证了即便服务器端的进程暂时没有调用accept()来处理新连接，
             客户端与服务器之间的连接也能保持，直到被应用程序处理

7.TCP为什么是三次握手？而不是两次、四次？
    为什么不是两次？
        1.防止无用的连接的建立
         如果客户端因为网络延迟收不到ACK，一直重发SYN，
         服务端每收到一个SYN就只能先主动建立一个连接，将会造成很多重复的无效的连接
        2.过滤历史连接
        3.需要同步初始序列号
        TCP是全双工通信，其实本质上全双工通信是需要4次握手的，不过由于第2次和第3次可以合并成一次，所以就成了三次握手

8.TCP粘包的原因？
    1：TCP协议的流式特性 TCP本身对于发送的数据包就是当做一串无结构的字节流。
    2：Nagle算法  该算法会等待收集一定量的小数据包，合并成一个大的数据包再发送，以减少网络中的小包数量，这可能导致原数据包边界消失。
    3：接收缓冲区处理  接收方可能由于处理速度不及接收速度，导致多个数据包累积在缓冲区中，当从缓冲区读取数据时，可能会一次性读到多个数据包的内容。

9.TCP为什么要拆包？
    1. MTU（最大传输单元）限制
    2. MSS（最大段大小）协商
    3. 提高网络效率
    4. 流量控制
    5. 拥塞控制
    怎么解决TCP粘包问题？
        需要再应用层设计相应的协议来定义数据包的边界
    1.定长消息
        每个消息的大小固定，接收方按照预定长度读取消息。
    2.消息头
        在每个消息前添加包含消息长度的信息，接收方先读取消息头获取长度，再根据长度读取消息体。
    3.分隔符
        在消息之间使用特定的分隔符，接收方通过识别分隔符来拆分

10.拔掉网线后，TCP连接还在不在？
    1.有数据传输：
        客户端拔网线后，服务端发数据无响应，引发重传机制
        客户端重连发送数据，因服务端端口无匹配连接，将以RST响应，客户端接收到后关闭连接，最终双侧TCP连接均告终
    2.没有数据传输：
        如果没有开启 TCP keepalive 机制，在客户端拔掉网线后，并且双方都没有进行数据传输，那么客户端和服务端的 TCP 连接将会一直保持存在。
        而如果开启了 TCP keepalive 机制，在客户端拔掉网线后，即使双方都没有进行数据传输，在持续一段时间后，TCP 就会发送探测报文来确定对方的 TCP 连接是否存活;

11.TIME_WAIT状态的作用是？
    1.保证双方都能正确关闭
        如果没有TIME_WAIT状态的话，客户端最后一次发送ack应答报文后就进入了close阶段。
        如果服务端没有收到ack报文的话，就会重传FIN报文，而此时客户端已经close了，就会返回一个RST错误报文。
    2.防止错误的历史报文

12. TCP 连接建立时使用 随机序列号 的主要原因是 安全性和防止连接劫持
    1. 防止重放攻击
    2. 防止预测序列号（序列号碰撞）
    3. 防止序列号重复

13.为什么Time_Wait状态需要持续2MSL?
    1.2MSL就是一个发送报文和一个回复报文所需要的最大时间，
      如果直到2MSL，客户端没有再次收到FIN，那么客户端认为服务端已经收到了ACK，则结束TCP连接。
    2.客户端要保证第四个数据包（最后一个ACK包）能被服务器收到，怎么保证呢？就是通过等待 2MSL，第四个数据包传递到服务器需要 1 MSL，
      如果中间丢失了，服务器就会再发送第五个数据包（重传FIN）去让客户端重新发第四个包，这第五个包传递到客户端又需要 1MSL 时间。
      所以客户端为了确保第四个数据包能被服务器收到，就要等待 2MSL 时间。
    注意：客户端收到重传的FIN会重置Time_Wait的时间。

14.现在客户端不知道第三次握手丢失，在第二次握手后，客户端就立马给服务端发送了数据包，服务端会怎么处理？
    1.在第三次握手未完成的情况下，服务器进入 半开连接 状态，在此状态下，服务器已经发送了 SYN-ACK 包，等待客户端发送 ACK 包以完成三次握手。但在三次握手完成前，服务器 不认为连接已经完全建立
    2.收到客户端的数据包：
        a.服务器会首先检查该数据包的序列号和连接状态
        b.因为连接还没有完全建立（第三次握手尚未完成），服务器会拒绝该数据包或丢弃该数据包，通常会发送一个 RST（复位）包，告知客户端连接不可用，或者直接丢弃不做处理。
        c.服务器会向客户端发送一个 RST（Reset）包，表示当前的连接请求未完成，无法继续处理数据。
        d.客户端收到 RST 包后，会知道连接没有建立，通常会放弃发送数据，并可能重试连接（例如重新发送 SYN 包）。
        