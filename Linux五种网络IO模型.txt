在Linux系统中，网络I/O模型是指应用程序与操作系统之间如何交互以进行网络数据的传输。Linux支持多种网络I/O模型，它们各自有不同的特点和适用场景。常见的五种网络I/O模型如下：
1. 阻塞I/O（Blocking I/O）
    描述：
        在阻塞I/O模型中，应用程序执行read()或write()等系统调用时，会阻塞，直到操作完成为止。在进行网络I/O时，如果没有数据可读，read()会一直阻塞，直到有数据可以读取。
    如果没有空闲的写缓冲区，write()也会阻塞，直到可以写入。
    特点：
        简单直观，易于实现。
        如果没有数据或者需要写入的缓冲区不可用，程序会处于阻塞状态，直到I/O操作完成。
        适合请求-响应模式的应用（如HTTP请求的处理），但对于高并发和低延迟要求的场景，性能可能会成为瓶颈。
    适用场景：
        一般情况下，当应用程序对I/O的响应时间要求不高，且不需要处理大量并发连接时，阻塞I/O模型是一个不错的选择。
    示例：
        int sockfd = socket(AF_INET, SOCK_STREAM, 0);
        connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr));
        char buffer[1024];
        int n = read(sockfd, buffer, sizeof(buffer));  // 阻塞直到数据到来
2. 非阻塞I/O（Non-blocking I/O）
    描述：
        在非阻塞I/O模型中，应用程序调用read()或write()时，如果操作无法立即完成（例如没有数据可读或写缓冲区已满），系统调用会立即返回，返回值表示操作失败，应用程序需要自己处理重试。
    特点：
        不会阻塞，系统调用会立刻返回，即使没有数据可读。
        需要程序自己轮询I/O操作，频繁检查是否可以进行数据操作（通常通过select()、poll()或epoll()机制来实现）。
        对于需要高并发的场景，能够有效避免阻塞带来的性能问题。
    适用场景：
        适用于多任务和高并发的应用程序，比如Web服务器、代理服务器等。
    示例：
        int sockfd = socket(AF_INET, SOCK_STREAM, 0);
        fcntl(sockfd, F_SETFL, O_NONBLOCK);  // 设置非阻塞模式
        char buffer[1024];
        int n = read(sockfd, buffer, sizeof(buffer));  // 非阻塞，立即返回
        if (n == -1) {
            // 处理错误或重新尝试
        }
3. I/O多路复用（I/O Multiplexing）
    描述：
        I/O多路复用是一种允许单个进程同时监控多个文件描述符（如多个套接字）的技术。应用程序通过系统调用select()、poll()或epoll()来检查多个I/O操作是否就绪。只有在某个I/O操作可用时，应用程序才会去执行读取或写入操作。
    特点：
        适合需要同时处理多个并发连接的情况，如Web服务器或代理服务器。
        应用程序可以使用单个线程或进程处理多个连接，避免为每个连接创建一个独立的线程或进程，减少了系统资源的开销。
        select()和poll()对于大量并发连接性能较差，因为它们会在每次调用时扫描所有文件描述符。epoll是针对Linux系统优化的I/O多路复用机制，适用于大规模的并发连接。
    适用场景：
        高并发应用，特别是当系统资源有限时，如Web服务器、聊天服务器等。
    示例：
        fd_set readfds;
        FD_ZERO(&readfds);
        FD_SET(sockfd, &readfds);
        select(sockfd + 1, &readfds, NULL, NULL, NULL);  // 等待套接字可读
        if (FD_ISSET(sockfd, &readfds)) {
            // 处理可读数据
        }
4. 信号驱动I/O（Signal-driven I/O）
    描述：
        信号驱动I/O模型是通过信号来通知应用程序某个I/O操作已经就绪。当I/O操作可以继续进行时，操作系统会向应用程序发送一个信号（通常是SIGIO）。应用程序通过注册信号处理函数来处理这些事件。
    特点：
        应用程序可以在信号到达时被中断，然后去进行相应的I/O操作。
        适用于对实时性要求较高的场景，但信号驱动I/O的实现复杂度较高。
        需要注意信号的处理，避免信号丢失或处理不当。
    适用场景：
        需要高响应性，但不希望轮询（如嵌入式系统或实时系统）。
    示例：
        fcntl(sockfd, F_SETFL, O_ASYNC);  // 设置为异步I/O模式
        signal(SIGIO, handler);           // 设置信号处理函数
5. 异步I/O（Asynchronous I/O）
    描述：
        在异步I/O模型中，应用程序发出I/O请求后，不需要等待操作系统完成I/O操作。操作系统会在操作完成时通知应用程序，通常通过回调机制或通知标志。应用程序可以继续进行其他任务，不需要一直等待I/O操作的完成。
    特点：
        完全非阻塞，应用程序发起I/O请求后，立即返回，操作系统在操作完成后通知应用程序。
        提高了系统的并发性能和响应性，适用于需要高吞吐量和低延迟的应用。
        实现较为复杂，涉及到回调机制和事件通知。
    适用场景：
        需要高并发、低延迟和高性能的应用，如大规模的数据库服务器、文件服务器等。
    示例：
        异步I/O通常通过aio_read()、aio_write()等API实现，Linux的libaio库提供了对异步I/O的支持。
        struct aiocb cb;
        memset(&cb, 0, sizeof(struct aiocb));
        cb.aio_fildes = sockfd;
        cb.aio_buf = buffer;
        cb.aio_nbytes = sizeof(buffer);
        cb.aio_offset = 0;
        aio_read(&cb);  // 发起异步读取

总结
模型	                                 特点	                                              适用场景
阻塞I/O	                          简单，I/O操作会阻塞，直到完成	                            一般应用，低并发场景。
非阻塞I/O	                   系统调用立即返回，需轮询检查I/O操作状态	                 高并发场景，如需要管理多个连接的服务器。
I/O多路复用	              单线程处理多个I/O操作，通过select、poll或epoll监控I/O事件	      高并发服务器，尤其是有限资源的情况。
信号驱动I/O	                         通过信号通知I/O事件的发生	                                高响应性应用，如实时系统。
异步I/O	                        完全非阻塞，操作完成后通过回调通知应用程序	             高性能、高并发、低延迟的应用，如数据库服务器。
